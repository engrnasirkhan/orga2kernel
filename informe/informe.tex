\documentclass[a4paper,10pt]{article}
\usepackage{graphicx}
\usepackage{verbatim}
% \usepackage{lstlisting}
\usepackage{subfig}
\usepackage{float}
 \usepackage[spanish]{babel}   %ver bien como es
\usepackage[utf8]{inputenc}
\usepackage{moreverb}
\hoffset=-2.5cm
\textwidth=17cm
\begin{document}
 
\title{
	\mbox{\Huge Universidad de Buenos Aires}\\
	\mbox{\huge Facultad de Ciencias Exactas y Naturales}\\
	\vspace{20mm}
	\mbox{\textbf{Trabajo Pr\'actico Final}}\\
	\mbox{\textbf{Organización del Computador II}}\\
	\mbox{\textbf{Nombre del SO}}\\
	\vspace{8mm}
}
\author{\Large\textbf{Profesor:} Ing. Alejandro Furfaro}
\date{}
\maketitle \thispagestyle{empty}

\begin{center}
    \vspace{15mm}
    \textbf{Integrantes}\\

    \begin{tabular}{|l|l|l|}
        \hline
        \textit{Apellido y Nombre} & \textit{L.U.} & \textit{Mail} \\
        \hline
		Aguerre, Ezequiel & 246/07 & ezeaguerre@gmail.com \\
        \hline
		Carrillo, Facundo & 693/07 & facu.zeta@gmail.com \\
	    \hline
		Pivetta, Santiago & 318/08 & santiago.pivetta@gmail.com \\
        \hline
		Semelman, Mariano & 143/08 & marianosoy@gmail.com \\
        \hline
    \end{tabular}
\end{center}


\begin{center}
    \vspace{10mm}
    \textbf{Abstract:}\\    
   En este proyecto emprendemos el arduo trabajo de implementar un Sistema operativo basado en la arquitectura IA32.
    \vspace{5mm}
\end{center}

\begin{center}
    \vspace{5mm}
    \textbf{Palabras Clave:}\\
		IA32 Kernel
    \vspace{5mm}
\end{center}



\newpage
\tableofcontents
\newpage



\section{Introducci\'on}
%\addcontentsline{toc}{section}{Introducci\'on}
El siguiente trabajo tiene como fin aplicar los conocimientos adquiridos en Organización del Computador II, Dpto de Computación, Facultad de Ciencias Exactas y Naturales, Universidad de Buenos Aires.	El proyecto incluye la creacion de un "Sistema Operativo" programado en el lenguaje C y Assembler IA32.
\\
\\
\begin{figure}[H]
\centering
\subfloat{\includegraphics[width=0.25\textwidth]{imagenes/capas.png}}
\caption{Diagrama de capas.}
\end{figure}

El diseño del sistema esta bastante influenciado por \emph{Understanding The Linux Kernel, 3rd Edition}. Propone un sistema de segmentación flat, paginación y multi task.

\newpage
\section{Organizaci\'on del C\'odigo Fuente}
% \addcontentsline{toc}{section}{Organizaci\'on del C\'odigo Fuente}
A continuacion se presenta la jerarquia del codigo fuente.

\begin{figure}[H]
\centering
\subfloat{\includegraphics[width=0.5\textwidth]{imagenes/goblal.png}}
\caption{Diagrama de jerarquia de archivos.}
\end{figure}

\begin{figure}[H]
\centering
\subfloat{\includegraphics[width=0.5\textwidth]{imagenes/diagrama_de_archivos_include.png}}
\caption{Diagrama de jerarquia de archivos (cont).}
\end{figure}

\begin{figure}[H]
\centering
\subfloat{\includegraphics[width=0.5\textwidth]{imagenes/diagrama_de_archivos_src.png}}
\caption{Diagrama de jerarquia de archivos (cont).}
\end{figure}


\section{Bootloader}
\newpage
\input{mmu.tex}

\newpage

\section{Scheduler}

Para la realizaci\'on del Scheduler se implement\'o una pol\'itica de Round Robin. Cada tarea tiene un quantum variable que se gasta cada 1 timertick y al terminar éste se pasa a la ejecuci\'on de la siguiente tarea.
Se uso fuertemente en este la funcionalidad del mmu, por lo cual se serializo el trabajo.

Toda la funcionalidad del Scheduler se encuentra en tres archivos:
\begin{itemize}
\item	- scheduler.h
\item	- tss.h
\item	- scheduler.c
\end{itemize}

En la cual podemos encontrar la siguiente estructura que define a una tarea.

\begin{verbatim}
      typedef struct {
          char hay_tarea;						
          unsigned int quantum_fijo;			
          unsigned int quantum_actual;		
          char *pantalla;					
          void *va_tss;						
          void *pa_tss;						
      } tarea;
\end{verbatim}

Contamos con las siguientes variables globales:

\begin{verbatim}
      tarea tareas[10];
      char tarea_activa;	
      char tarea_en_pantalla;
      char contador_actualizar_pantalla;
      programs_t* programas[5];
\end{verbatim}


Y con las siguientes funciones:

\begin{itemize}
\item \begin{verbatim}void menu(); \end{verbatim}
\item \begin{verbatim}void scheduler();\end{verbatim}
\item \begin{verbatim}void matar_tarea(char numero_tarea);\end{verbatim}
\item \begin{verbatim}void mostrar_slot(char s);\end{verbatim}
\item \begin{verbatim}void iniciar_scheduler();\end{verbatim}
\item \begin{verbatim}void crear_tarea(programs_t programa, char numero_tarea);\end{verbatim}
\end{itemize}

\subsection*{ void menu()}
Es el procedimiento encargado mostrar el menu de texto (el cual explica la operatoria) por pantalla.

\subsection*{ void scheduler()}
Es el procedimiento encargado de pasar a la siguiente tarea, consultando las variables globales, elije la próxima tarea y hace un jmp a ella. Modificando las variables correspondientes para conservar la coherencia.

\subsection*{ void matar\_tarea(char numero\_tarea) }
Es el procedimiento encargado de desalojar la tarea \begin{it}numero\_tarea\end{it} del sistema. Libera toda la memoria que pidio al iniciarla y actualiza variables para conservar la coherencia.

\subsection*{void mostrar\_slot(char s)}
Es el procedimiento encargado de mostrar en pantalla la tarea \begin{it}s\end{it} pasada como argumento. Pasando del buffer de pantalla de \begin{it}s\end{it} a la pantalla real, la informacion correspondiente.

\subsection*{void iniciar\_scheduler()}
Es el procedimiento encargado de setear todas las variables iniciales para el buen funcionamiento del schduler. También lanza el menu.

\subsection*{void crear\_tarea(programs\_t programa, char numero\_tarea)}
Es el procedimiento encargado de ingresar un programa al sistema, conviertiendolo en tarea. Se ejecuta en un entorno Kernel.
El siguiente pseudocodigo especifica su función.
\begin{verbatim}
void crear_tarea(programs programa, char numero_tarea){
    
    Deshabilitamos Interrupciones.
    Si existe tarea corriendo en slot numero_tarea la matamos.
    Creamos nuevo directorio tabla de pagina.
    Creamos tss para nueva tarea.
    Pedimos paginas para codigo y mapeamos en el DTP de la tarea a ingresar.
    Copiamos codigo a paginas pedidas.
    Pedimos pagina para pila y mapeamos en el DTP de la tarea a ingresar.
    Modificamos GDT para agregar el Descriptor correspondiente a esta tarea.
    Llenamos tss con los datos validos.
    Creamos buffer de video para nueva tarea.
    Mapeamos la 0xb8000 al DTP de la nueva tarea a su buffer.
    Modificamos las variables correspondientes al scheduler.
    Habilitamos interrupciones.
}
\end{verbatim}
\newpage
\section{Teclado y TTY (o Prompt)}
Fue necesario para poder interactuar con el sistema implementar un controlador de teclado simple y . El cual permitiera de forma básica aprovechar la interacción del usuario con el sistema. Para ello implementamos una serie de funciones (ubicadas en keyboard.c). Este driver funciona en conjunto con un módulo llamado tty ofreciendo varias funcionalidades.\\
Tales funcionalidades son registrar una función a una tecla de modo que cuando se pulse esa tecla en vez de ingresarse al prompt se dispare la suscitada función. También lograr que tener la cantidad necesarios de "prompts" como se necesite, y configurar que cuando se introduzcan letras a través de ese prompt sean dirigidos al "prompt" correspondiete.

Para todo esto se provee la siguiente interfaz:

\begin{verbatim}

En el driver de video (screen.c)
    //funcion que recibe un caracter o una serie de ellos y los imprime en la zona de prompt
    size_t kprint_tty(uint8_t * );
    //funcion que limpia el prompt
    void kprint_tty_clear();
    //funcion para borrar un caracter
    void kprint_tty_backspace();


tty_buffer_out_f  //tipo de funcion que recibe el buffer que se escribe en el prompt

//los prompt o tty se pueden crear dinamicamente e ir guardando en una lista.
//es por eso que se utilizo esta estructura para guardar toda la informacion 
//necesarias para administrar cada uno de los prompt.
struct tty_tty_node {
    
    tty_t tty;
    uint8_t buff[MAX_TTY+2];
    uint32_t buff_pos;
    bool expects_char;
    bool expects_string;
    bool enabled;
    tty_buffer_out_f buffer_out;
    void * next;
};

/*escribe un caracter en el prompt */
void tty_put_key(key);
/*el proximo caracter que se presione se enviara a travez del tty_buffer_out_f asociado
 * solo si no se pidio */
bool tty_get_key(tty_t* tty);
/*la proxima linea que se ingrese se enviara a travez del tty_buffer_out_f asociado
 * solo si no se pidio */
bool tty_get_string(tty_t* tty);
/* inicializa el tty con 1 TTYs al comienzo */
int tty_init(tty_t* tty, tty_buffer_out_f out_f);
/* agrega un tty con un buffer asociado, tty es de salida, devuelve el tty asociado a esta vista. */
int tty_tty_add(tty_t* tty, tty_buffer_out_f out_f);
/* cambia al tty designado */
int tty_tty_change(tty_t* tty);
\end{verbatim}

Por lo que la idea es inicializar las tty con tty\_init, agregar todas las tty que se necesiten con tty\_add , e ir cambiando entre ellas con tty\_change. Se decidio implementar que siempre se recibe un puntero a tty\_t, lo cual funciona muy parecido a libreria pthread, de modo que es tanto entrada como salida segun como se necesite, cuando se crea se deja alli el valor, y para las demas acciones es de entrada. Por lo que el creador de cada tty debe administrar de alguna forma cada tty con los tty\_t.

Cada uno de estos tty permiten llamar a las funcion $tty\_get\_string$ y $tty\_get_char$ las cuales, en el momento que ocurra el evento deseado (tanto un enter como la entrada de un caracter), llamarán a la funcion previamente designada a este tty. Es importante notar que esta acción es asincronica, por lo que se deberia hacer polling (busy waiting) sobre algun variable de estado, o (más adelante) implementar que las tareas sean marcadas como ocupadas.

\newpage
\section{C\'omo usar el SO}
% \addcontentsline{toc}{section}{C\'omo usar el SO}
Para ir al menu se debe presionar la tecla Esc. Ahi mismo podra ingresar todo lo que el menu lo ofrece mediante las instruciones detalladas.
Con las teclas F1, F2,...,F10 podra moverse entre las tareas que tiene en ejecución.


\end{document}
