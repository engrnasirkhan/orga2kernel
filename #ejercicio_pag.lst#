     1                                  BITS 16
     2                                  
     3                                  global start
     4                                  start:
     5 00000000 FA                      		cli
     6 00000001 E9C400                   		jmp bienvenida
     7                                  	
     8                                  %include "segments.mac"
     9                              <1> %define S.G  1h<<23+32
    10                              <1> %define S.D_B 1h<<22+32
    11                              <1> %define S.L 1h<<21+32
    12                              <1> %define S.AVL 0h
    13                              <1> %define S.P 1h<<15+32
    14                              <1> %define S.S 1h<<(12+32)
    15                              <1> %define S.TYPE(x) x<<40	
    16                              <1> %define S.DPL(x) x<<13+32
    17                              <1> %define S.LIMIT(x) ( (0xffff & x) | ((x & 0xf_0000)<<32) )
    18                              <1> 	
    19                              <1> %define S.BASE(x) (( x & 0xff00_0000 ) << 32 ) | 	(( x & 0x00ff_0000 ) << 16 ) | 	(( x & 0x0000_ffff ) << 16 )
    20                                  %include "gdt.asm"
    21                              <1> BEGIN_GDT:		
    22                              <1> ;; Primer segmento nulo
    23 00000004 0000000000000000    <1> dq 0x0
    24                              <1> ;; segmento de codigo 0x8
    25 0000000C FFFF0000009BCF00    <1> dq	S.BASE(0x0)| 	S.LIMIT(0xFFFFF) | 	S.TYPE(1011b) | 	S.G | 	S.D_B | 	S.P | 	S.S
    26                              <1> ;; segmento de datos 0x10
    27 00000014 FFFF00000093CF00    <1> dq 	S.BASE(0x0) | 	S.LIMIT(0xFFFFF) | 	S.TYPE(0011b) | 	S.G | 	S.D_B | 	S.P | 	S.S
    28                              <1> ;; segmento de video 0x18
    29 0000001C 9F0F00B800934000    <1> dq 	S.BASE(0xb800) | 	S.LIMIT( (25*80*2) - 1 ) | 	S.TYPE(0011b) | 	S.D_B | 	S.P | 	S.S
    30                              <1> 	
    31                              <1> END_GDT:
    32                              <1> GDT_SIZE:	
    33 00000024 2000                <1> GDT_DESC:	dw END_GDT-BEGIN_GDT	 	
    34 00000026 [04000000]          <1> 		dd BEGIN_GDT
    35                              <1> 
    36                              <1> 		
    37                              <1> 
    38                              <1> 
    39                              <1> 
    40                              <1> ;; begin_page_directory:
    41                              <1> ;; ;; |	   base | reserved  |pat|avl| g |ps | d | a |pcd|pwt|u/s|r/w| P |
    42                              <1> ;; ;;  00_0000_0000_0_0000_0000___0_000___1___0___0___0___0___1___0___1___1b
    43                              <1> ;; dd 0x10b + begin_page_table
    44                              <1> ;; end_page_directory:
    45                              <1> ;; times (4096 - (end_page_directory-begin_page_directory)) db 0x0
    46                              <1> 
    47                              <1> ;; begin_page_table:
    48                              <1> ;; ;; mi kernel tiene 0x3040 bytes y arranca en 0x1200
    49                              <1> ;; ;; asi si hago identity mapping necesito paginar en la 
    50                              <1> ;; ;; tabla de paginas hasta 0x4240
    51                              <1> 
    52                              <1> ;; ;; |	   base        base |pat|avl| g |ps | d | a |pcd|pwt|u/s|r/w| P |
    53                              <1> ;; ;;  00_0000_0000_0_0000_0000___0_000___1___0___0___0___0___1___0___1___1b
    54                              <1> 
    55                              <1> ;; %assign i 0
    56                              <1> ;; %rep 6
    57                              <1> ;;      dd i<<12 | 0x0000010b
    58                              <1> ;;      %assign i i+1
    59                              <1> ;; %endrep
    60                              <1> ;; ;;ahora en 0x6000 tengo la memoria de video
    61                              <1> ;; dd 0xb8000 | 0x0000010b
    62                              <1> ;; end_page_table:
    63                              <1> ;; times (4096 - (end_page_table-begin_page_table)) db 0x0
    64                              <1> 
    65                                  %include "idt.asm"
    66                              <1> BEGIN_IDT:	
    67 0000002A 0000000000000000    <1> dq 0x0
    68                              <1> END_IDT:
    69 00000032 0800                <1> IDT_SIZE:	dw END_IDT-BEGIN_IDT
    70 00000034 [2A000000]          <1> 		dd BEGIN_IDT
    71                                  %include "messages.asm"
    72 00000038 41686F726120657374- <1> paginado: db "Ahora estoy paginado"
    73 00000041 6F7920706167696E61- <1>
    74 0000004A 646F                <1>
    75 0000004C 00                  <1> 	db 0
    76 0000004D 41686F726120657374- <1> protegido: db "Ahora estoy protegido"
    77 00000056 6F792070726F746567- <1>
    78 0000005F 69646F              <1>
    79 00000062 00                  <1> 	db 0
    80                              <1> 
    81                                  %include "print_protegido.asm"
    82                              <1> BITS 16
    83                              <1> 
    84                              <1> %define param(x) ebp+(x*4)
    85                              <1> 
    86                              <1> print:
    87 00000063 60                  <1> 	pusha
    88 00000064 6689E5              <1> 	mov ebp, esp
    89 00000067 6681C520000000      <1> 	add ebp, 0x20
    90                              <1> 	;; ebp queda apuntando al eip de retorno	
    91 0000006E 06                  <1> 	push es
    92 0000006F 1E                  <1> 	push ds
    93                              <1> 
    94                              <1> 	;; apunto es al segmento de datos
    95                              <1> 	;; junto con es:edi apunto al string
    96 00000070 B81000              <1> 	mov ax, 0x10
    97 00000073 8EC0                <1> 	mov es, ax 
    98                              <1> 	
    99 00000075 67668B7D04          <1>  	mov edi, [param(1)]		;puntero al string
   100                              <1> 	
   101                              <1> 	;; calculo el largo del string que al final tiene un 0
   102 0000007A FC                  <1> 	cld 			;limpio el flag de direccion
   103 0000007B 6631C9              <1> 	xor ecx, ecx
   104 0000007E 66F7D1              <1> 	not ecx
   105                              <1> 	
   106 00000081 30C0                <1> 	xor al, al
   107 00000083 F2AE                <1> 	repnz scasb
   108                              <1> 
   109 00000085 6689CB              <1> 	mov ebx, ecx
   110 00000088 6631C9              <1> 	xor ecx, ecx
   111 0000008B 66F7D1              <1> 	not ecx
   112 0000008E 6629D9              <1> 	sub ecx, ebx
   113                              <1> 	;; en ecx tengo la cantidad de caracteres
   114                              <1> 	;; ds:esi puntero al string
   115                              <1> 	;; es:edi puntero a la pantalla
   116 00000091 B81000              <1> 	mov ax, 0x10
   117 00000094 8ED8                <1> 	mov ds, ax
   118 00000096 67668B7504          <1>  	mov esi, [param(1)]	
   119                              <1> 	
   120 0000009B B81800              <1> 	mov ax, 0x18	; segmento de video
   121 0000009E 8EC0                <1> 	mov es, ax
   122                              <1> 	
   123 000000A0 6689CB              <1> 	mov ebx, ecx
   124 000000A3 66D1FB              <1> 	sar ebx, 1 		; cantidad de carateres/2
   125                              <1> 	;; calculo para ubicar el string
   126                              <1> 	;; en el centro de la pantalla
   127 000000A6 66B828000000        <1> 	mov eax, 40		; 80/2 centro de las columnas
   128 000000AC 6629D8              <1> 	sub eax, ebx 		; columna donde comienzo el print
   129 000000AF 66BB70030000        <1> 	mov ebx, 880		; 11 * 80
   130 000000B5 6601C3              <1> 	add ebx, eax
   131 000000B8 66D1E3              <1> 	sal ebx, 1
   132                              <1> 	
   133 000000BB 6689DF              <1> 	mov edi, ebx 		; ubico el puntero a la pantalla	
   134                              <1> 
   135 000000BE B43F                <1> 	mov ah, 0x3F
   136                              <1> 	
   137                              <1> .ciclo:	
   138 000000C0 AC                  <1> 	lodsb
   139 000000C1 AB                  <1> 	stosw
   140 000000C2 E2FC                <1> 	loop .ciclo
   141                              <1> 	
   142 000000C4 1F                  <1> 	pop ds
   143 000000C5 07                  <1> 	pop es
   144 000000C6 61                  <1> 	popa
   145 000000C7 C3                  <1> 	ret
   146                                  	
   147                                  bienvenida:
   148 000000C8 0F0116[2400]            	lgdt 	[GDT_DESC]			
   149                                  	;seteamos el bit PE del registro cr0
   150 000000CD 0F20C0                  	mov 	eax, cr0
   151 000000D0 660D01000000            	or  	eax, 01h
   152 000000D6 0F22C0                  	mov 	cr0, eax		
   153                                  	;segundo segmento en la GDT, el primero es nulo
   154 000000D9 EA[DE00]0800             	jmp 	0x08:modo_protegido
   155                                  
   156                                  BITS 32
   157                                  modo_protegido:
   158                                  
   159 000000DE 66B81000                 	mov 	ax, 0x10
   160 000000E2 8ED8                     	mov 	ds, ax		;acomodo el segmento de datos antes de hacer lio
   161 000000E4 8EC0                     	mov 	es, ax		;acomodo el segmento de datos antes de hacer lio
   162 000000E6 8EE0                     	mov 	fs, ax		;acomodo el segmento de datos antes de hacer lio
   163 000000E8 8EE8                    	mov 	gs, ax		;acomodo el segmento de datos antes de hacer lio
   164 000000EA 8ED0                     	mov	ss, ax		;acomodo el segmento de pila antes de usarla
   165                                  
   166 000000EC 8D05[4D000000]          	lea eax, [protegido]
   167 000000F2 50                      	push eax
   168 000000F3 E86BFFFFFF              	call print
   169 000000F8 81C404000000            	add esp, 4
   170                                  	
   171 000000FE E9FBFFFFFF              	jmp $
   172                                  
   173                                  	
   174                                  ;; 	call	idtFill
   175                                  	
   176                                  ;; 	lidt	[idt_desc]
   177                                  		
   178                                  
   179                                  ;; 		imprimir_protegido iniciando_juan, iniciando_juan_len
   180                                  				
   181                                  ;; 		genero un GP
   182                                  ;; 		mov ax, 0
   183                                  ;; 		mov es, ax
   184                                  ;; 		mov [es:0x0], edi
   185                                  
   186                                  ;; 		mov eax, begin_page_directory
   187                                  ;; 		mov cr3, eax
   188                                  				
   189                                  ;; 		mov eax, cr0
   190                                  ;;     		or eax, 0x80000000
   191                                  ;; 		mov cr0, eax
   192                                  ;; modo_prot_pag:		
   193                                  ;; 		imprimir_paginado estoy_paginado, estoy_paginado_len
   194                                  	
   195                                  ;; 		mov [es:edi], edi
   196                                  
   197                                  ;; 		.cicloazul:
   198                                  ;; 			;xchg bx, bx
   199                                  ;;  			stosw
   200                                  ;; 			loop 	.cicloazul
   201                                  ;; 			mov 	ecx, mensaje_len
   202                                  ;; 		mov 	edi, ((10 * 80) + 13) << 1
   203                                  		
   204                                  ;; 		mov 	ah, 0x1A
   205                                  ;; 		mov 	esi, mensaje
   206                                  		
   207                                  ;; 		.ciclo:
   208                                  ;; 			lodsb
   209                                  ;; 			stosw
   210                                  ;; 			loop .ciclo
   211                                  			
   212                                  		
   213                                  ;; 		jmp 	$
   214                                  		
   215                                  ;; mensaje:	db 'Mi vieja mula ya no es lo que era! (ahora protegidos :) )'
   216                                  ;; mensaje_len equ $ - mensaje
   217                                  
   218                                  ;; gp_handler:
   219                                  ;;     ; nos salteamos el error code
   220                                  ;;     imprimir_protegido gp_exception, gp_exception_len
   221                                  ;;     add esp, 4
   222                                  ;;     iret
   223                                  
   224                                  ;; pf_handler:
   225                                  ;;     imprimir_protegido pf_exception, pf_exception_len
   226                                  ;;     add esp, 4
   227                                  ;;     iret
   228                                  
   229                                  
   230                                  ;; %include "a20.asm"
   231                                  
   232                                  
   233                                  
   234                                  
