     1                                  BITS 16
     2                                  %define ORIGIN 0x1200
     3                                  global start
     4                                  start:
     5 00000000 FA                      		cli
     6 00000001 E90000                   		jmp bienvenida
     7                                  		
     8                                  bienvenida:
     9 00000004 0F0116[6300]            	lgdt 	[GDT_DESC]			
    10                                  	;seteamos el bit PE del registro cr0
    11 00000009 0F20C0                  	mov 	eax, cr0
    12 0000000C 660D01000000            	or  	eax, 01h
    13 00000012 0F22C0                  	mov 	cr0, eax		
    14                                  	;segundo segmento en la GDT, el primero es nulo
    15 00000015 EA[1A00]0800             	jmp 	0x08:modo_protegido
    16                                  
    17                                  BITS 32
    18                                  modo_protegido:
    19                                  	
    20 0000001A 0F011D[4A010000]        	lidt [IDT_DESC]
    21                                  
    22 00000021 66B81000                 	mov 	ax, 0x10
    23 00000025 8ED8                     	mov 	ds, ax		;acomodo el segmento de datos antes de hacer lio
    24 00000027 8EC0                     	mov 	es, ax		;acomodo el segmento de datos antes de hacer lio
    25 00000029 8EE0                     	mov 	fs, ax		;acomodo el segmento de datos antes de hacer lio
    26 0000002B 8EE8                    	mov 	gs, ax		;acomodo el segmento de datos antes de hacer lio
    27 0000002D 8ED0                     	mov	ss, ax		;acomodo el segmento de pila antes de usarla
    28                                  	
    29 0000002F 8D05[65010000]          	lea eax, [protegido]
    30 00000035 50                      	push eax
    31 00000036 E840010000              	call print
    32 0000003B CD40                    	int 0x40
    33                                  lop:
    34 0000003D 40                      	inc eax
    35 0000003E E9FAFFFFFF              	jmp lop
    36                                  	
    37                                  %include "segments.mac"
    38                              <1> %define S.G  1h<<23+32
    39                              <1> %define S.D_B 1h<<22+32
    40                              <1> %define S.L 1h<<21+32
    41                              <1> %define S.AVL 0h
    42                              <1> %define S.P 1h<<15+32
    43                              <1> %define S.S 1h<<(12+32)
    44                              <1> %define S.TYPE(x) x<<40	
    45                              <1> %define S.DPL(x) x<<13+32
    46                              <1> %define S.LIMIT(x) ( (0xffff & x) | ((x & 0xf_0000)<<32) )
    47                              <1> 	
    48                              <1> %define S.BASE(x) (( x & 0xff00_0000 ) << 32 ) | 	(( x & 0x00ff_0000 ) << 16 ) | 	(( x & 0x0000_ffff ) << 16 )
    49                                  %include "gdt.asm"
    50                              <1> BEGIN_GDT:		
    51                              <1> ;; Primer segmento nulo
    52 00000043 0000000000000000    <1> dq 0x0
    53                              <1> ;; segmento de codigo 0x8
    54 0000004B FFFF0000009BCF00    <1> dq	S.BASE(0x0)| 	S.LIMIT(0xFFFFF) | 	S.TYPE(1011b) | 	S.G | 	S.D_B | 	S.P | 	S.S
    55                              <1> ;; segmento de datos 0x10
    56 00000053 FFFF00000093CF00    <1> dq 	S.BASE(0x0) | 	S.LIMIT(0xFFFFF) | 	S.TYPE(0011b) | 	S.G | 	S.D_B | 	S.P | 	S.S
    57                              <1> ;; segmento de video 0x18
    58 0000005B 9F0F00800B934000    <1> dq 	S.BASE(0xb8000) | 	S.LIMIT( (25*80*2) - 1 ) | 	S.TYPE(0011b) | 	S.D_B | 	S.P | 	S.S
    59                              <1> 	
    60                              <1> END_GDT:
    61                              <1> GDT_SIZE:	
    62 00000063 2000                <1> GDT_DESC:	dw END_GDT-BEGIN_GDT	 	
    63 00000065 [43000000]          <1> 		dd BEGIN_GDT
    64                              <1> 
    65                              <1> 		
    66                              <1> 
    67                              <1> 
    68                              <1> 
    69                              <1> ;; begin_page_directory:
    70                              <1> ;; ;; |	   base | reserved  |pat|avl| g |ps | d | a |pcd|pwt|u/s|r/w| P |
    71                              <1> ;; ;;  00_0000_0000_0_0000_0000___0_000___1___0___0___0___0___1___0___1___1b
    72                              <1> ;; dd 0x10b + begin_page_table
    73                              <1> ;; end_page_directory:
    74                              <1> ;; times (4096 - (end_page_directory-begin_page_directory)) db 0x0
    75                              <1> 
    76                              <1> ;; begin_page_table:
    77                              <1> ;; ;; mi kernel tiene 0x3040 bytes y arranca en 0x1200
    78                              <1> ;; ;; asi si hago identity mapping necesito paginar en la 
    79                              <1> ;; ;; tabla de paginas hasta 0x4240
    80                              <1> 
    81                              <1> ;; ;; |	   base        base |pat|avl| g |ps | d | a |pcd|pwt|u/s|r/w| P |
    82                              <1> ;; ;;  00_0000_0000_0_0000_0000___0_000___1___0___0___0___0___1___0___1___1b
    83                              <1> 
    84                              <1> ;; %assign i 0
    85                              <1> ;; %rep 6
    86                              <1> ;;      dd i<<12 | 0x0000010b
    87                              <1> ;;      %assign i i+1
    88                              <1> ;; %endrep
    89                              <1> ;; ;;ahora en 0x6000 tengo la memoria de video
    90                              <1> ;; dd 0xb8000 | 0x0000010b
    91                              <1> ;; end_page_table:
    92                              <1> ;; times (4096 - (end_page_table-begin_page_table)) db 0x0
    93                              <1> 
    94                                  %include "idt.asm"
    95                              <1> 
    96                              <1> %define CG.OFFSET(x) 	(0xffff & x) | ((0xffff_0000 & x)<<32)
    97                              <1> %define CG.SELECTOR(x) ((0xffff & x)<<16)
    98                              <1> %define CG.TYPE(x) ((x & 1111b) << 40) 
    99                              <1> %define CG.PARAM(x) ((1_1111b & x) << 32 )
   100                              <1> %define CG.P 1b<<15+32
   101                              <1> %define CG.DPL(x) (x & 11b)<<13
   102                              <1> 
   103                              <1> %include "isr.asm"
   104                              <2> isr7:
   105 00000069 60                  <2> 	pusha
   106                              <2> 	
   107 0000006A 8D05[7E000000]      <2> 	lea eax, [isr7_msg]
   108 00000070 50                  <2> 	push eax
   109 00000071 E805010000          <2> 	call print
   110 00000076 81C404000000        <2> 	add esp, 4
   111                              <2> 	
   112 0000007C 61                  <2> 	popa
   113 0000007D CF                  <2> 	iret
   114 0000007E 495352203700        <2> isr7_msg: db	"ISR 7",0
   115                              <2> isr8:
   116 00000084 60                  <2> 	pusha
   117                              <2> 	
   118 00000085 8D05[99000000]      <2> 	lea eax, [isr8_msg]
   119 0000008B 50                  <2> 	push eax
   120 0000008C E8EA000000          <2> 	call print
   121 00000091 81C404000000        <2> 	add esp, 4
   122                              <2> 	
   123 00000097 61                  <2> 	popa
   124 00000098 CF                  <2> 	iret
   125                              <2> 
   126 00000099 495352203800        <2> isr8_msg: db	"ISR 8",0
   127                              <2> isr13:
   128 0000009F 60                  <2> 	pusha
   129                              <2> 	
   130 000000A0 8D05[B3000000]      <2> 	lea eax, [isr13_msg]
   131 000000A6 6810000000          <2> 	push dword 0x10
   132                              <2> ;; 	call print
   133 000000AB 81C404000000        <2> 	add esp, 4
   134                              <2> 	
   135 000000B1 61                  <2> 	popa
   136 000000B2 CF                  <2> 	iret
   137 000000B3 49535220313300      <2> isr13_msg: db	"ISR 13",0
   138                              <1> 	
   139                              <1> BEGIN_IDT:
   140                              <1> 	;; isr 0
   141 000000BA 0000000000000000    <1> dq 0x0
   142                              <1> 	;; isr 1
   143 000000C2 0000000000000000    <1> dq 0x0
   144                              <1> 	;; isr 2
   145 000000CA 0000000000000000    <1> dq 0x0
   146                              <1> 	;; isr 3
   147 000000D2 0000000000000000    <1> dq 0x0
   148                              <1> 	;; isr 4
   149 000000DA 0000000000000000    <1> dq 0x0
   150                              <1> 	;; isr 5
   151 000000E2 0000000000000000    <1> dq 0x0
   152                              <1> 	;; isr 6
   153 000000EA 0000000000000000    <1> dq 0x0
   154                              <1> 	;; isr 7
   155 000000F2 69120800008E0000    <1> dq CG.P | CG.TYPE(1110b) | CG.OFFSET( isr7-$$+ORIGIN ) | CG.SELECTOR(0x8)
   156                              <1> 	;; isr 8
   157 000000FA 84120800008E0000    <1> dq CG.P | CG.TYPE(1110b) | CG.OFFSET( isr8-$$+ORIGIN ) | CG.SELECTOR(0x8)
   158                              <1> 	;; isr 9
   159 00000102 0000000000000000    <1> dq 0x0
   160                              <1> 	;; isr 10
   161 0000010A 0000000000000000    <1> dq 0x0
   162                              <1> 	;; isr 11
   163 00000112 0000000000000000    <1> dq 0x0
   164                              <1> 	;; isr 12
   165 0000011A 0000000000000000    <1> dq 0x0
   166                              <1> 	;; isr 13
   167 00000122 9F120800008E0000    <1> dq CG.P | CG.TYPE(1110b) | CG.OFFSET( isr13-$$+ORIGIN ) | CG.SELECTOR(0x8)
   168                              <1> 
   169 0000012A 0000000000000000    <1> dq 0x0
   170 00000132 0000000000000000    <1> dq 0x0
   171 0000013A 0000000000000000    <1> dq 0x0
   172 00000142 0000000000000000    <1> dq 0x0
   173                              <1> END_IDT:
   174                              <1> IDT_SIZE:
   175 0000014A 9000                <1> IDT_DESC:	dw END_IDT-BEGIN_IDT
   176 0000014C [BA000000]          <1> 		dd BEGIN_IDT
   177                                  %include "messages.asm"
   178 00000150 41686F726120657374- <1> paginado: db "Ahora estoy paginado"
   179 00000159 6F7920706167696E61- <1>
   180 00000162 646F                <1>
   181 00000164 00                  <1> 	db 0
   182 00000165 41686F726120657374- <1> protegido: db "Ahora estoy protegido"
   183 0000016E 6F792070726F746567- <1>
   184 00000177 69646F              <1>
   185 0000017A 00                  <1> 	db 0
   186                              <1> 
   187                                  %include "print_protegido.asm"
   188                              <1> 
   189                              <1> 
   190                              <1> %define param(x) ebp+(x*4)
   191                              <1> 
   192                              <1> print:
   193 0000017B 60                  <1> 	pusha
   194 0000017C 89E5                <1> 	mov ebp, esp
   195 0000017E 81C520000000        <1> 	add ebp, 0x20
   196                              <1> 	;; ebp queda apuntando al eip de retorno	
   197 00000184 06                  <1> 	push es
   198 00000185 1E                  <1> 	push ds	
   199                              <1> 
   200                              <1> 	;; corro todas las lineas
   201                              <1> 	;; de la pantalla hacia arriba
   202 00000186 66B81800            <1> 	mov ax, 0x18
   203 0000018A 8EC0                <1> 	mov es, ax
   204 0000018C 8ED8                <1> 	mov ds, ax
   205                              <1> 
   206 0000018E 31FF                <1> 	xor edi, edi
   207 00000190 BEA0000000          <1> 	mov esi, 80<<1 		;80 columnas de word
   208                              <1> 
   209 00000195 B980070000          <1> 	mov ecx, 80*24
   210 0000019A F366A5              <1> 	rep movsw	
   211                              <1> 	
   212                              <1> 	;; apunto es al segmento de datos
   213                              <1> 	;; junto con es:edi apunto al string
   214 0000019D 66B81000            <1> 	mov ax, 0x10
   215 000001A1 8EC0                <1> 	mov es, ax
   216                              <1> 	
   217 000001A3 8B7D04              <1>  	mov edi, [param(1)]		;puntero al string
   218                              <1> 	
   219                              <1> 	;; calculo el largo del string que al final tiene un 0
   220 000001A6 FC                  <1> 	cld 			;limpio el flag de direccion
   221 000001A7 31C9                <1> 	xor ecx, ecx
   222 000001A9 F7D1                <1> 	not ecx
   223                              <1> 	
   224 000001AB 30C0                <1> 	xor al, al
   225 000001AD F2AE                <1> 	repnz scasb
   226                              <1> 
   227 000001AF 89CB                <1> 	mov ebx, ecx
   228 000001B1 31C9                <1> 	xor ecx, ecx
   229 000001B3 F7D1                <1> 	not ecx
   230 000001B5 29D9                <1> 	sub ecx, ebx
   231                              <1> 	;; en ecx tengo la cantidad de caracteres
   232                              <1> 	;; ds:esi puntero al string
   233                              <1> 	;; es:edi puntero a la pantalla
   234 000001B7 66B81000            <1> 	mov ax, 0x10
   235 000001BB 8ED8                <1> 	mov ds, ax
   236 000001BD 8B7504              <1>  	mov esi, [param(1)]
   237                              <1> 	
   238 000001C0 66B81800            <1> 	mov ax, 0x18
   239 000001C4 8EC0                <1> 	mov es, ax
   240 000001C6 BF000F0000          <1> 	mov edi, 80*24*2 	;me paro en la ultima linea
   241                              <1> 
   242 000001CB B43F                <1> 	mov ah, 0x3F
   243                              <1> 	
   244                              <1> .ciclo:	
   245 000001CD AC                  <1> 	lodsb
   246 000001CE 66AB                <1> 	stosw
   247 000001D0 E2FB                <1> 	loop .ciclo
   248                              <1> 	
   249 000001D2 1F                  <1> 	pop ds
   250 000001D3 07                  <1> 	pop es
   251 000001D4 61                  <1> 	popa
   252 000001D5 C3                  <1> 	ret
   253                                  
   254                                  	
   255                                  ;; 	call	idtFill
   256                                  	
   257                                  ;; 	lidt	[idt_desc]
   258                                  		
   259                                  
   260                                  ;; 		imprimir_protegido iniciando_juan, iniciando_juan_len
   261                                  				
   262                                  ;; 		genero un GP
   263                                  ;; 		mov ax, 0
   264                                  ;; 		mov es, ax
   265                                  ;; 		mov [es:0x0], edi
   266                                  
   267                                  ;; 		mov eax, begin_page_directory
   268                                  ;; 		mov cr3, eax
   269                                  				
   270                                  ;; 		mov eax, cr0
   271                                  ;;     		or eax, 0x80000000
   272                                  ;; 		mov cr0, eax
   273                                  ;; modo_prot_pag:		
   274                                  ;; 		imprimir_paginado estoy_paginado, estoy_paginado_len
   275                                  	
   276                                  ;; 		mov [es:edi], edi
   277                                  
   278                                  ;; 		.cicloazul:
   279                                  ;; 			;xchg bx, bx
   280                                  ;;  			stosw
   281                                  ;; 			loop 	.cicloazul
   282                                  ;; 			mov 	ecx, mensaje_len
   283                                  ;; 		mov 	edi, ((10 * 80) + 13) << 1
   284                                  		
   285                                  ;; 		mov 	ah, 0x1A
   286                                  ;; 		mov 	esi, mensaje
   287                                  		
   288                                  ;; 		.ciclo:
   289                                  ;; 			lodsb
   290                                  ;; 			stosw
   291                                  ;; 			loop .ciclo
   292                                  			
   293                                  		
   294                                  ;; 		jmp 	$
   295                                  		
   296                                  ;; mensaje:	db 'Mi vieja mula ya no es lo que era! (ahora protegidos :) )'
   297                                  ;; mensaje_len equ $ - mensaje
   298                                  
   299                                  ;; gp_handler:
   300                                  ;;     ; nos salteamos el error code
   301                                  ;;     imprimir_protegido gp_exception, gp_exception_len
   302                                  ;;     add esp, 4
   303                                  ;;     iret
   304                                  
   305                                  ;; pf_handler:
   306                                  ;;     imprimir_protegido pf_exception, pf_exception_len
   307                                  ;;     add esp, 4
   308                                  ;;     iret
   309                                  
   310                                  
   311                                  ;; %include "a20.asm"
   312                                  
   313                                  
   314                                  
   315                                  
